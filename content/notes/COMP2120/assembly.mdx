---
title: Assembly Language Programming
---

## Introduction

Assembly language is a low-level programming language that is very *instruction set architecture* (ISA) specific. Our courses focuses on the following ISA:
* Comments are preceded by `#`
* Destination operands are on the **right** of the operands list
* Instructions are case *insensitive*

!!! info "Syntax"

    Each line of assembly language consists of:

    ```assembly
    label: mnemonic operand1, operand2, ... # comment
    ```

    * `label` is an optional label that can be used to refer to the instruction later
    * `mnemonic` is either a operand or a *assembler directive*
    * `operandx` is the operand(s) for the operation
    * `comment` is an optional comment that describes the instruction

!!! note "Assembler directive"

    An assembler directive is a command to the assembler, not an instruction to the CPU. They start with a `.` and are not executed by the CPU:

    | Directive | Description |
    | ---|---|
    | `.data` | Adds the subsequent data to the data segment | 
    | `.text` | Adds the subsequent code to the **program** |
    | `.global NAME` | Makes the label `NAME` visible to other modules |
    | `.space <EXPRESSION>` | Reserves space with the size of `<EXPRESSION>`  in bytes, filled with `0`s | 
    | `.word value1 [, value2, ...]` | Put the values in *successive* memory locations, each occupying *4 bytes* | 

## Flow control

!!! tip "If else structure"

    ```cpp
    if (a[0] > a[1]): x = a[0];
    else: x = a[1];
    ```

    ```assembly
        .data               # declare start of data segment
    a:  .word 1             # a[0] = 1
        .word 2             # a[1] = 2
    x:  .word 0             # x = 0
        .text               # declare start of code segment
    
    main:                   # main function
        ld  #a, r8          # set r8 to adress of a[0]
        ld 0(r8), r9        # set r9 to a[0]
        ld 4(r8), r10       # set r10 to a[1] (4 bytes after a[0])
        bgt r9, r10, then   # if a[0] > a[1], goto then
        st r10, x           # else: x = a[1]
        br end

    then:
        st r9, x            # x = a[0]
    end:
        ret                 # return to caller
    ```

!!! tip "For loop structure"

    ```cpp
    a = 0;
    for (int i = 0; i < 10; i++) a += i;
    ```

    ```assembly
        .data                   # declare start of data segment
    a:  .word 0                 # initialize a to 0
        .text                   # declare start of code segment

    main:                       # main function
        sub r8, r8, r8          # prepare r8 = 0 as the counter
        ld 10, r9               # constant 10 in r9
        ld 1, r10               # constant 1 in r10 for incrementing r8
        sub r11, r11, r11       # use r11 as sum

    L:  add r11, r8, r11        # r11 += r8
        add r8, r10, r8         # r8++
        bgt r9, r8, L           # branch to L if r9 (10) > r8 (counter)
        st r11, a               # store the result in a
        ret                     # return to caller
    ```

!!! tip "Function calling"

    Use `call` to call a function and `ret` to return from a function. Unlike high-level languages, you must manage the parameters and result of the function yourself. 
    
    * Specify the input and output parameter registers in the function's comment
    * Use `push` and `pop` to save and restore registers temporarily. 